1	1	1	A→B 이고 B→C 일 때, A→C 를 만족하는 관계
2	1	2	A→B 이고 B→C 일 때, C→A 를 만족하는 관계
3	1	3	A→B 이고 B→C 일 때, B→A 를 만족하는 관계
4	1	4	A→B 이고 B→C 일 때, C→B 를 만족하는 관계
5	2	1	πR1(σP(A1))
6	2	2	σA1(πP(R1))
7	2	3	πA1(σP(R1))
8	2	4	σR1(πP(A1))
9	3	1	DELETE, UPDATE, CREATE, ALTER
10	3	2	INSERT, DELETE, UPDATE, DROP
11	3	3	SELECT, INSERT, DELETE, UPDATE
12	3	4	SELECT, INSERT, DELETE, ALTER
13	4	1	Requirement Formulation → Conceptual Schema → Physical Schema → Logical Schema
14	4	2	Logical Schema → Requirement Formulation → Conceptual Schema → Physical Schema
15	4	3	Requirement Formulation → Conceptual Schema → Logical Schema → Physical Schema
16	4	4	Logical Schema → Requirement Formulation → Physical Schema → Conceptual Schema
17	5	1	A
18	5	2	D
19	5	3	E
20	5	4	F
21	6	1	(ㄱ)
22	6	2	(ㄴ), (ㄷ)
23	6	3	(ㄱ), (ㄷ), (ㄹ)
24	6	4	(ㄱ), (ㄴ), (ㄷ), (ㄹ)
25	7	1	한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
26	7	2	속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값이다.
27	7	3	한 릴레이션에 포함된 튜플들은 모두 상이한다.
28	7	4	한 릴레이션을 구성하는 속성들 사이의 순서는 존재하며, 중요한 의미를 가진다.
29	8	1	사용자에 대한 응답시간 최소화
30	8	2	시스템 활용도 최대화
31	8	3	데이터베이스 일관성 유지
32	8	4	데이터베이스 공유도 최소화
33	9	1	개체
34	9	2	속성
35	9	3	도메인
36	9	4	제약조건
37	10	1	오너 - 멤버 (Owner-Member) 관계라고도 한다.
38	10	2	개체 타입과 이들 간의 관계 타입을 기본 요소로 이용하여 현실 세계를 개념적으로 표현한다.
39	10	3	E-R 다이어그램에서 개체 타입은 사각형으로 나타낸다.
40	10	4	E-R 다이어그램에서 속성은 타원으로 나타낸다.
41	11	1	Overflow
42	11	2	Top = Top+1
43	11	3	Underflow
44	11	4	Top = Top-2
45	12	1	Definition 기능
46	12	2	Control 기능
47	12	3	Manipulation 기능
48	12	4	Strategy 기능
49	13	1	GROUP BY
50	13	2	ORDER BY
51	13	3	UPDATE
52	13	4	JOIN
53	14	1	파일 탐색 효율이 우수하며, 접근 시간 및 응답 시간이 빠르기 때문에 대화형 처리에 적합하다.
54	14	2	연속적인 레코드의 저장에 의해 레코드 사이에 빈 공간이 존재하지 않으므로 기억장치의 효율적인 이용이 가능하다.
55	14	3	필요한 레코드를 삽입, 삭제, 수정하는 경우 파일을 재구성해야 하므로 파일 전체를 복사해야 한다.
56	14	4	어떤 형태의 입출력 매체에서도 처리가 가능하다.
57	15	1	consistency
58	15	2	atomicity
59	15	3	isolation
60	15	4	durability
61	16	1	로킹 단위가 크면 병행성 수준이 낮아진다.
62	16	2	로킹 단위가 크면 병행 제어 기법이 복잡해진다.
63	16	3	로킹 단위가 작으면 로크(lock)의 수가 적어진다.
64	16	4	로킹은 파일 단위로 이루어지며, 레코드 또는 필드는 로킹 단위가 될 수 없다.
65	17	1	Degree
66	17	2	Cardinality
67	17	3	Attribute
68	17	4	Cartesian product
69	18	1	3, 4, 8, 7, 9
70	18	2	3, 4, 9 ,7, 8
71	18	3	7, 8, 3, 4, 9
72	18	4	3, 8, 4, 9, 7
73	19	1	정규화를 거치지 않으면 여러 가지 상이한 종류의 정보를 하나의 릴레이션으로 표현하여 그 릴레이이션을 조작할 때 이상(Anomaly) 현상이 발생할 수 있다.
74	19	2	정규화의 목적은 각 릴레이션에 분산된 종속성을 하나의 릴레이션에 통합 하는 것이다.
75	19	3	이상(Anomaly) 현상은 데이터들 간에 존재하는 함수 종속이 하나의 원인이 될 수 있다.
76	19	4	정규화가 잘못되면 데이터의 불필요한 중복이 야기되어 릴레이션을 조작할 때 문제가 발생할 수 있다.
77	20	1	1
78	20	2	2
79	20	3	3
80	20	4	4
81	21	1	분기 번지
82	21	2	메모리
83	21	3	제어규칙
84	21	4	누산기
85	22	1	제어장치의 구현이 간단하다.
86	22	2	중앙처리장치의 시간이 이용이 비효율적이다.
87	22	3	여러 종류의 MO 수행시 CPU사이클 타임이 실제적인 오퍼레이션 시간보다 길다.
88	22	4	MO이 끝나고 다음 오퍼레이션이 수행될 될 때까지 시간지연이 있게 되어 CPU 처리 속도가 느려진다.
89	23	1	24F2H 번지
90	23	2	24F5H 번지
91	23	3	24F8H 번지
92	23	4	256DH 번지
93	24	1	0- 주소 명령어 형식은 PUSH/POP 연산을 사용한다.
94	24	2	1- 주소 명령어 형식은 누산기를 사용한다.
95	24	3	2- 주소 명령어 형식은 MOVE 명령이 필요하다.
96	24	4	3- 주소 명령어 형식은 내용이 연산 결과 저장으로 소멸된다.
97	25	1	10H
98	25	2	11H
99	25	3	12H
100	25	4	15H
101	26	1	17
102	26	2	18
103	26	3	19
104	26	4	20
105	27	1	1 Mbytes/sec
106	27	2	10 Mbytes/sec
107	27	3	100 Mbytes/sec
108	27	4	1000 Mbytes/sec
109	28	1	PLA(Programmable Logic Array)
110	28	2	PAL(Programmable Array Logic)
111	28	3	LPGA(Field Programmable Gate Array)
112	28	4	CPLD(Complex Programmable Logic Device)
113	29	1	Common operation
114	29	2	Axis operation
115	29	3	Micro operation
116	29	4	Count operation
117	30	1	-256 ~ +256'
118	30	2	-128 ~ +127'
119	30	3	-128 ~ +128'
120	30	4	-256 ~ +127'
121	31	1	"3-2-4-1-5	"
122	31	2	5-3-2-1-4
123	31	3	"3-2-1-4-5	"
124	31	4	5-3-2-4-1
125	32	1	XOR 연산
126	32	2	AND 연산
127	32	3	OR 연산
128	32	4	NOT 연산
129	33	1	분산처리 프로그래밍
130	33	2	일괄처리 프로그래밍
131	33	3	멀티 프로그래밍
132	33	4	리얼타임 프로그래밍
133	34	1	크로스 링커
134	34	2	크로스 어셈블러
135	34	3	메크로 어셈블러
136	34	4	매크로 컴파일러
137	35	1	인출(Fetch)
138	35	2	간접(Indirect)
139	35	3	실행(Execute)
140	35	4	메모리(Memory)
141	36	1	X₀
142	36	2	X1
143	36	3	X2
144	36	4	X3
145	37	1	DNA
146	37	2	채널
147	37	3	데이터 버스
148	37	4	입출력 프로세서
149	38	1	1100
150	38	2	1011
151	38	3	0011
152	38	4	1010
153	39	1	③ → ② → ④ → ⑤ → ①
154	39	2	① → ③ → ② → ⑤ → ④
155	39	3	② → ③ → ④ → ⑤ → ①
156	39	4	④ → ③ → ② → ⑤ → ①
157	40	1	channel
158	40	2	handshaking
159	40	3	interrupt
160	40	4	emulation
161	41	1	많은 원격 접근들은 캐싱이 사용될 때 지역 캐쉬에 의해서 효율적으로 처리될 수 맀다.
162	41	2	캐쉬- 일관성 문제는 캐싱의 가장 큰 결점이다.
163	41	3	모든 원격 접근은 원격- 서비스 방법이 사용 될 때 네트워크를 통해서만 처리된다.
164	41	4	캐쉬- 일관성 문제는 쓰기 접근 빈도가 많은 접근형태에서 캐싱이 우수하다.
165	42	1	790
166	42	2	380
167	42	3	370
168	42	4	250
169	43	1	임계구역에 2개의 프로세서가 들어갈 수 있다.
170	43	2	두 개의 임계구역이 존재한다.
171	43	3	모든 세마포어의 기본 값은 2이다.
172	43	4	생산자/소비자를 구현하는 세마포어의 초기 값은 2이다.
173	44	1	FIFO
174	44	2	HRN
175	44	3	MFQ
176	44	4	RR
177	45	1	영역 1
178	45	2	영역 2
179	45	3	영역 3
180	45	4	영역 4
181	46	1	자체의 내장 명령어 제공
182	46	2	파이프라인 기능
183	46	3	주기억장치에 상주
184	46	4	입출력 방향지정
185	47	1	일단계 디렉토리
186	47	2	트리 구조 디렉토리
187	47	3	이단계 디렉토리
188	47	4	비주기 디렉토리
189	48	1	모니터의 경계에서 상호배제가 시행된다.
190	48	2	자료추상화와 정보은폐 기법을 기초로 한다.
191	48	3	공유 데이터와 이 데이터를 처리하는 프로시저로 구성된다.
192	48	4	모니터 외부에서도 모니터 내의 데이터를 직접 액세스 할 수 있다.
193	49	1	분산된 노드들은 통신 네트워크를 이용하여 메시지를 주고 받은으로서 정보를 교환한다.
194	49	2	사용자에게 동적으로 할당할 수 있는 일반적인 자원들이 각 노드에 분산되어 있다.
195	49	3	시스템 전체의 정책을 결정하는 어떤 통합적인 제거 기능은 필요하지 않다.
196	49	4	사용자는 특정 자원의 물리적 위치를 알지 못하여도 사용할 수 있다.
197	50	1	DES는 비대칭형 암호화 기법이다.
198	50	2	RSA는 공개키/비밀키 암호화 기법이다.
199	50	3	디지털 서명은 비대칭형 암호 알고리즘을 사용 한다.
200	50	4	DES 알고리즘에서 키 관리가 매우 중요하다.
201	51	1	480K
202	51	2	430K
203	51	3	260K
204	51	4	170K
205	52	1	처리율 극대화
206	52	2	평균 반응시간의 단축
207	52	3	응답시간의 최소화
208	52	4	디스크 공간 확보
209	53	1	프로세스 식별정보
210	53	2	프로세스 제어정보
211	53	3	프로세스(CPU) 상태정보
212	53	4	프로세스 생성정보
213	54	1	Absolute Loader
214	54	2	Direct Linking Loader
215	54	3	Dynarnic Loader
216	54	4	Compile and Go Loader
217	55	1	Ring Connected
218	55	2	Multiaccess Bus Connected
219	55	3	Partially Connected
220	55	4	Fully Connected
221	56	1	입/출력의 인터럽트
222	56	2	외부 인터럽트
223	56	3	기계 검사 인터럽트
224	56	4	프로그램 검사 인터럽트
225	57	1	DES(Data Encryption Standard)
226	57	2	RSA(Rivest Shamir Adleman)
227	57	3	Reed-Solomon code
228	57	4	FEAL(Fast Encryption Algorithm)
229	58	1	프로그램 검사 인터럽트
230	58	2	SVC 인터럽트
231	58	3	입·출력 인터럽트
232	58	4	외부 인터럽트
233	59	1	USER BLOCK
234	59	2	BOOT BLOCK
235	59	3	INODE LIST
236	59	4	SUPER BLOCK
237	60	1	cp
238	60	2	chmod
239	60	3	cat
240	60	4	ls
241	61	1	Hipo-chart
242	61	2	Test Case
243	61	3	Source Code
244	61	4	Project Plan
245	62	1	변경 발생 시 오류의 파급효과가 적다.
246	62	2	인터페이스가 단순화 된다.
247	62	3	소프트웨어 재사용성이 높아진다.
248	62	4	상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다.
249	63	1	소프트웨어 모듈의 재사용성이 향상된다.
250	63	2	자동화된 기법을 통해 소프트웨어 품질이 향상된다.
251	63	3	소프트웨어 사용자들이 소프트웨어 사용 방법을 신속히 숙지할 수 있도록 개발된 자동화 패키지이다.
252	63	4	소프트웨어 유지보수를 간편하게 수행할 수 있다
253	64	1	Common Facilities
254	64	2	Application Interface
255	64	3	User Interface
256	64	4	Domain Interface
257	65	1	객체지향 분석
258	65	2	구조적 분석
259	65	3	기능적 분석
260	65	4	실시간 분석
261	66	1	Encapsulation
262	66	2	Abstraction
263	66	3	Inheritance
264	66	4	Polymorphism
265	67	1	시스템 개발을 위한 분석과 설계가 용이하다.
266	67	2	프램그램 유지보수가 용이다.
267	67	3	프로그램의 확장성이 있다.
268	67	4	프로그램 개발 인력이 감소된다.
269	68	1	보헴 (Boehm)이 제안한 소스 코드 (Source Code) 의 규모에 의한 비용예측 모델이다.
270	68	2	소프트웨어 프로젝트 유형에 따라 다르게 책정되는 비용 산정 수식(Equation)을 이용한다.
271	68	3	COCOMO 방법은 가정과 제약조건이 없어 모든 시스템에 동일하게 적용할 수 맀다.
272	68	4	같은 규모의 소프트웨어라도 그 유형에 따라 비용이 다르게 산정된다.
273	69	1	Reliability
274	69	2	Correctness
275	69	3	Portability
276	69	4	Efficiency
277	70	1	가-데이터, 나- 명령문
278	70	2	가-명령문, 나- 의문문
279	70	3	가-의문문, 나- 제어문
280	70	4	가- 동사, 나- 명사
281	71	1	4GT Model
282	71	2	Spiral Model
283	71	3	Waterfall Model
284	71	4	Prototype Model
285	72	1	PROBLEM
286	72	2	PROCESS
287	72	3	PASSING
288	72	4	PEOPLE
289	73	1	데이터 흐름의 표현
290	73	2	데이터 구조의 표현
291	73	3	데이터 구조들과 그들 간의 관계들을 표현
292	73	4	데이터 사전을 표현
293	74	1	분석(analysis)
294	74	2	재구성(restructuring)
295	74	3	역공학(reverse engineering)
296	74	4	이식(migeation)
297	75	1	프로젝트 자체 요소로 문제의 복잡도, 시스템의 규모, 요구되는 신뢰도 등이 있다
298	75	2	개발에 필요한 인적 자원, 하드웨어 자원, 소프트웨어 자원 등이 있다.
299	75	3	Person-Month(PM) 당 제작되는 평균 LOC(Line of Code) 등이 있다.
300	75	4	프로젝트 관리 방법론에 따라 생산된 문서와 관리 비용 등이 있다
301	76	1	정확성
302	76	2	무결성
303	76	3	간결성
304	76	4	일관성
305	77	1	1, 4
306	77	2	1, 2, 3
307	77	3	1, 2, 4
308	77	4	1, 2, 3, 4
309	78	1	Flow Chart
310	78	2	HIPO Chart
311	78	3	Control Specification
312	78	4	Box Diagram
313	79	1	소프트웨어 개발 요구의 다양화
314	79	2	소프트웨어 규모의 증대와 복잡도에 따른 개발 비용의 감소
315	79	3	작업일정과 비용의 추정치가 부정확
316	79	4	새로운 소프트웨어의 오류율이 고객 불만과 신뢰결여를 유발
317	80	1	비용과 일정에 대한 제약설정
318	80	2	타당성 조사
319	80	3	요구사항 정의 문서화
320	80	4	설계 명세서 작성
321	81	1	슬립(slip)
322	81	2	폴링 (polling)
323	81	3	피기백(piggyback)
324	81	4	인터리빙(interleaving)
325	82	1	TDM
326	82	2	DSSS
327	82	3	OFDM
328	82	4	FHSS
329	83	1	10.240.0.0
330	83	2	10.0.0.32
331	83	3	10.1.16.3
332	83	4	10.29.240.0
333	84	1	가드 밴드(Guard Band)
334	84	2	채널(Channel)
335	84	3	버퍼(Buffer)
336	84	4	슬롯(Slot)
337	85	1	1계층
338	85	2	2계층
339	85	3	3계층
340	85	4	4계층
341	86	1	패리티 체크 방식
342	86	2	군계수 체크 방식
343	86	3	SQD 방식
344	86	4	정 마크(정 스페이스)방식
345	87	1	DPCM
346	87	2	DM
347	87	3	LPC
348	87	4	FDM
349	88	1	4
350	88	2	8
351	88	3	16
352	88	4	64
353	89	1	전송 오류 검출
354	89	2	데이터 처리
355	89	3	주소 인식
356	89	4	정보 저장
357	90	1	RF
358	90	2	L2CAP
359	90	3	HID
360	90	4	RFCOMM
361	91	1	16
362	91	2	32
363	91	3	64
364	91	4	128
365	92	1	프래그 - 제어영역 - 주소영역 - 정보영역 - FCS - 프래그
366	92	2	프래그 - 주소영역 - 제어영역 - 정보영역 - FCS - 프래그
367	92	3	프래그 - 주소영역 - 정보영역 - 제어영역 - FCS - 프래그
368	92	4	프래그 - 정보영역 - 제어영역 - 주소영역 - FCS - 프래그
369	93	1	SOH
370	93	2	ACK
371	93	3	SYN
372	93	4	EOT
373	94	1	150
374	94	2	300
375	94	3	600
376	94	4	750
377	95	1	이더넷
378	95	2	토큰링
379	95	3	토큰버스
380	95	4	FDDI
381	96	1	2
382	96	2	3
383	96	3	4
384	96	4	5
385	97	1	개체(entity)
386	97	2	구문(syntax)
387	97	3	의미(semantic)
388	97	4	타이밍(timing)
389	98	1	최대 전송속도는 1000 kbps 이다.
390	98	2	베이스 밴드 전송 방식을 사용한다.
391	98	3	전송 매체는 UTP(꼬임쌍선) 이다.
392	98	4	주로 이더넷(Ethernet)에서 사용된다.
393	99	1	LAPB
394	99	2	LAPD
395	99	3	LAPX
396	99	4	LAPM
397	100	1	14400
398	100	2	10800
399	100	3	9600
400	100	4	7200
